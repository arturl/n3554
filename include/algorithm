#pragma once

#include <detail/config.hpp>
#include <execution_policy>
#include_next <algorithm>
#include <iostream>
#include <thrust/execution_policy.h>
#include <thrust/for_each.h>

namespace std
{


template<typename InputIterator, typename Function>
InputIterator __for_each(const sequential_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  std::cout << "for_each(sequential_execution_policy)" << std::endl;

  return thrust::for_each(thrust::seq, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const parallel_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  std::cout << "for_each(parallel_execution_policy)" << std::endl;

  return thrust::for_each(thrust::device, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const execution_policy &exec, InputIterator first, InputIterator last, Function f)
{
  std::cout << "for_each(execution_policy)" << std::endl;

  switch(__which(exec))
  {
    case 0:
      first = __for_each(__union(exec).seq, first, last, f);
      break;

    case 1:
      first = __for_each(__union(exec).par, first, last, f);
      break;
  }

  return first;
}


template<typename ExecutionPolicy, typename InputIterator, typename Function>
typename std::enable_if<
  std::is_execution_policy<
    typename std::decay<ExecutionPolicy>::type
  >::value,
  InputIterator
>::type
for_each(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Function f)
{
  return __for_each(exec, first, last, f);
}


}

