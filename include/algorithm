#pragma once

#include <detail/config.hpp>
#include <execution_policy>
#include_next <algorithm>
#include <iostream>
#include <thrust/execution_policy.h>
#include <thrust/logical.h>
#include <thrust/find.h>
#include <thrust/for_each.h>

namespace std
{


template<class InputIterator, class Predicate>
bool __all_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::all_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __all_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::all_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __all_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __all_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __all_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
bool __any_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::any_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __any_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::any_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __any_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __any_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __any_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
bool __none_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::none_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __none_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::none_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __none_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __none_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __none_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class T>
InputIterator __find(const sequential_execution_policy &, InputIterator first, InputIterator last, const T& value)
{
  return thrust::find(thrust::seq, first, last, value);
}


template<class InputIterator, class T>
InputIterator __find(const parallel_execution_policy &, InputIterator first, InputIterator last, const T& value)
{
  return thrust::find(thrust::device, first, last, value);
}


template<class InputIterator, class T>
InputIterator __find(const execution_policy &exec, InputIterator first, InputIterator last, const T& value)
{
  switch(__which(exec))
  {
    case 0:
      last = __find(__union(exec).seq, first, last, value);
      break;

    case 1:
      last = __find(__union(exec).par, first, last, value);
      break;
  }

  return last;
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  switch(__which(exec))
  {
    case 0:
      last = __find_if(__union(exec).seq, first, last, pred);
      break;

    case 1:
      last = __find_if(__union(exec).par, first, last, pred);
      break;
  }

  return last;
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if_not(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if_not(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  switch(__which(exec))
  {
    case 0:
      last = __find_if_not(__union(exec).seq, first, last, pred);
      break;

    case 1:
      last = __find_if_not(__union(exec).par, first, last, pred);
      break;
  }

  return last;
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const sequential_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2);
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const parallel_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2);
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const execution_policy &exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_end(__union(exec).seq, first1, last1, first2, last2);
      break;

    case 1:
      first1 = __find_end(__union(exec).par, first1, last1, first2, last2);
  }

  return first1;
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const sequential_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2, pred);
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const parallel_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2, pred);
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const execution_policy &exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_end(__union(exec).seq, first1, last1, first2, last2, pred);
      break;

    case 1:
      first1 = __find_end(__union(exec).par, first1, last1, first2, last2, pred);
  }

  return first1;
}


template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const sequential_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2);
}


template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const parallel_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2);
} 

template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const execution_policy &exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_first_of(__union(exec).seq, first1, last1, first2, last2);
      break;

    case 1:
      first1 = __find_first_of(__union(exec).par, first1, last1, first2, last2);
      break;
  }

  return first1;
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const sequential_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2, pred);
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const parallel_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2, pred);
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const execution_policy &exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_first_of(__union(exec).seq, first1, last1, first2, last2, pred);
      break;

    case 1:
      first1 = __find_first_of(__union(exec).par, first1, last1, first2, last2, pred);
      break;
  }

  return first1;
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const sequential_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  return thrust::for_each(thrust::seq, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const parallel_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  return thrust::for_each(thrust::device, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const execution_policy &exec, InputIterator first, InputIterator last, Function f)
{
  switch(__which(exec))
  {
    case 0:
      first = __for_each(__union(exec).seq, first, last, f);
      break;

    case 1:
      first = __for_each(__union(exec).par, first, last, f);
      break;
  }

  return first;
}


template<class ExecutionPolicy, class Result = void>
struct __enable_if_execution_policy
  : std::enable_if<
      std::is_execution_policy<
        typename std::decay<ExecutionPolicy>::type
      >::value,
      Result
    >
{};


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
all_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __all_of(exec, first, last, pred);
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
any_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __any_of(exec, first, last, pred);
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
none_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __none_of(exec, first, last, pred);
}


template<class ExecutionPolicy, class InputIterator, class T>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find(ExecutionPolicy &&exec, InputIterator first, InputIterator last, const T& value)
{
  return __find(exec, first, last, value);
}


template<class ExecutionPolicy, class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_if(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __find_if(exec, first, last, pred);
}


template<class ExecutionPolicy, class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_if_not(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __find_if_not(exec, first, last, pred);
}


template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator1>::type
find_end(ExecutionPolicy &&exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  return __find_end(exec, first1, last1, first2, last2);
}


template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator1>::type
find_end(ExecutionPolicy &&exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  return __find_end(exec, first1, last1, first2, last2, pred);
}


template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_first_of(ExecutionPolicy &&exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  return __find_first_of(exec, first1, last1, first2, last2);
}


template<class ExecutionPolicy, class InputIterator, class ForwardIterator, class BinaryPredicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_first_of(ExecutionPolicy &&exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  return __find_first_of(exec, first1, last1, first2, last2, pred);
}


template<typename ExecutionPolicy, typename InputIterator, typename Function>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
for_each(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Function f)
{
  return __for_each(exec, first, last, f);
}


}

