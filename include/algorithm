#pragma once

#include <detail/config.hpp>
#include <execution_policy>
#include_next <algorithm>
#include <iostream>
#include <thrust/execution_policy.h>
#include <thrust/logical.h>
#include <thrust/find.h>
#include <thrust/count.h>
#include <thrust/mismatch.h>
#include <thrust/for_each.h>

namespace std
{


template<class InputIterator, class Predicate>
bool __all_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::all_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __all_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::all_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __all_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __all_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __all_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
bool __any_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::any_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __any_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::any_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __any_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __any_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __any_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
bool __none_of(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::none_of(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __none_of(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::none_of(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
bool __none_of(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  bool result = false;

  switch(__which(exec))
  {
    case 0:
      result = __none_of(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __none_of(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<class InputIterator, class T>
InputIterator __find(const sequential_execution_policy &, InputIterator first, InputIterator last, const T& value)
{
  return thrust::find(thrust::seq, first, last, value);
}


template<class InputIterator, class T>
InputIterator __find(const parallel_execution_policy &, InputIterator first, InputIterator last, const T& value)
{
  return thrust::find(thrust::device, first, last, value);
}


template<class InputIterator, class T>
InputIterator __find(const execution_policy &exec, InputIterator first, InputIterator last, const T& value)
{
  switch(__which(exec))
  {
    case 0:
      last = __find(__union(exec).seq, first, last, value);
      break;

    case 1:
      last = __find(__union(exec).par, first, last, value);
      break;
  }

  return last;
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  switch(__which(exec))
  {
    case 0:
      last = __find_if(__union(exec).seq, first, last, pred);
      break;

    case 1:
      last = __find_if(__union(exec).par, first, last, pred);
      break;
  }

  return last;
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if_not(thrust::seq, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::find_if_not(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
InputIterator __find_if_not(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  switch(__which(exec))
  {
    case 0:
      last = __find_if_not(__union(exec).seq, first, last, pred);
      break;

    case 1:
      last = __find_if_not(__union(exec).par, first, last, pred);
      break;
  }

  return last;
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const sequential_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2);
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const parallel_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2);
}


template<class ForwardIterator1, class ForwardIterator2>
ForwardIterator1 __find_end(const execution_policy &exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_end(__union(exec).seq, first1, last1, first2, last2);
      break;

    case 1:
      first1 = __find_end(__union(exec).par, first1, last1, first2, last2);
  }

  return first1;
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const sequential_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2, pred);
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const parallel_execution_policy &, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_end(first1, last1, first2, last2, pred);
}


template<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
ForwardIterator1 __find_end(const execution_policy &exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_end(__union(exec).seq, first1, last1, first2, last2, pred);
      break;

    case 1:
      first1 = __find_end(__union(exec).par, first1, last1, first2, last2, pred);
  }

  return first1;
}


template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const sequential_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2);
}


template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const parallel_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2);
} 

template<class InputIterator, class ForwardIterator>
InputIterator __find_first_of(const execution_policy &exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_first_of(__union(exec).seq, first1, last1, first2, last2);
      break;

    case 1:
      first1 = __find_first_of(__union(exec).par, first1, last1, first2, last2);
      break;
  }

  return first1;
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const sequential_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2, pred);
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const parallel_execution_policy &, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  // XXX TODO
  return std::find_first_of(first1, last1, first2, last2, pred);
}


template<class InputIterator, class ForwardIterator, class BinaryPredicate>
InputIterator __find_first_of(const execution_policy &exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  switch(__which(exec))
  {
    case 0:
      first1 = __find_first_of(__union(exec).seq, first1, last1, first2, last2, pred);
      break;

    case 1:
      first1 = __find_first_of(__union(exec).par, first1, last1, first2, last2, pred);
      break;
  }

  return first1;
}


template<class InputIterator, class T>
typename std::iterator_traits<InputIterator>::difference_type
__count(const sequential_execution_policy &, InputIterator first, InputIterator last, const T &value)
{
  return std::count(first, last, value);
}


template<class InputIterator, class T>
typename std::iterator_traits<InputIterator>::difference_type
__count(const parallel_execution_policy &, InputIterator first, InputIterator last, const T &value)
{
  return thrust::count(thrust::device, first, last, value);
}


template<class InputIterator, class T>
typename std::iterator_traits<InputIterator>::difference_type
__count(const execution_policy &exec, InputIterator first, InputIterator last, const T &value)
{
  typename std::iterator_traits<InputIterator>::difference_type result(0);

  switch(__which(exec))
  {
    case 0:
      result = __count(__union(exec).seq, first, last, value);
      break;

    case 1:
      result = __count(__union(exec).par, first, last, value);
      break;
  }

  return result;
}


template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
__count_if(const sequential_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return std::count_if(first, last, pred);
}


template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
__count_if(const parallel_execution_policy &, InputIterator first, InputIterator last, Predicate pred)
{
  return thrust::count_if(thrust::device, first, last, pred);
}


template<class InputIterator, class Predicate>
typename std::iterator_traits<InputIterator>::difference_type
__count_if(const execution_policy &exec, InputIterator first, InputIterator last, Predicate pred)
{
  typename std::iterator_traits<InputIterator>::difference_type result(0);

  switch(__which(exec))
  {
    case 0:
      result = __count_if(__union(exec).seq, first, last, pred);
      break;

    case 1:
      result = __count_if(__union(exec).par, first, last, pred);
      break;
  }

  return result;
}


template<typename InputIterator1, typename InputIterator2>
pair<InputIterator1,InputIterator2>
__mismatch(const sequential_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  return std::mismatch(first1, last1, first2);
}


template<typename InputIterator1, typename InputIterator2>
pair<InputIterator1,InputIterator2>
__mismatch(const parallel_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  thrust::pair<InputIterator1,InputIterator2> result = thrust::mismatch(thrust::device, first1, last1, first2);
  return std::make_pair(result.first, result.second);
}


template<typename InputIterator1, typename InputIterator2>
pair<InputIterator1,InputIterator2>
__mismatch(const execution_policy &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  pair<InputIterator1,InputIterator2> result(first1,first2);

  switch(__which(exec))
  {
    case 0:
      result = __mismatch(__union(exec).seq, first1, last1, first2);
      break;

    case 1:
      result = __mismatch(__union(exec).par, first1, last1, first2);
      break;
  }

  return result;
}


template<typename InputIterator1, typename InputIterator2, typename Predicate>
pair<InputIterator1,InputIterator2>
__mismatch(const sequential_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  return std::mismatch(first1, last1, first2, pred);
}


template<typename InputIterator1, typename InputIterator2, typename Predicate>
pair<InputIterator1,InputIterator2>
__mismatch(const parallel_execution_policy &, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  thrust::pair<InputIterator1,InputIterator2> result = thrust::mismatch(thrust::device, first1, last1, first2, pred);
  return std::make_pair(result.first, result.second);
}


template<typename InputIterator1, typename InputIterator2, typename Predicate>
pair<InputIterator1,InputIterator2>
__mismatch(const execution_policy &exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  pair<InputIterator1,InputIterator2> result(first1,first2);

  switch(__which(exec))
  {
    case 0:
      result = __mismatch(__union(exec).seq, first1, last1, first2, pred);
      break;

    case 1:
      result = __mismatch(__union(exec).par, first1, last1, first2, pred);
      break;
  }

  return result;
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const sequential_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  return thrust::for_each(thrust::seq, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const parallel_execution_policy &, InputIterator first, InputIterator last, Function f)
{
  return thrust::for_each(thrust::device, first, last, f);
}


template<typename InputIterator, typename Function>
InputIterator __for_each(const execution_policy &exec, InputIterator first, InputIterator last, Function f)
{
  switch(__which(exec))
  {
    case 0:
      first = __for_each(__union(exec).seq, first, last, f);
      break;

    case 1:
      first = __for_each(__union(exec).par, first, last, f);
      break;
  }

  return first;
}


template<class ExecutionPolicy, class Result = void>
struct __enable_if_execution_policy
  : std::enable_if<
      std::is_execution_policy<
        typename std::decay<ExecutionPolicy>::type
      >::value,
      Result
    >
{};


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
all_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __all_of(exec, first, last, pred);
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
any_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __any_of(exec, first, last, pred);
}


template<class ExecutionPolicy,
         class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,bool>::type
none_of(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __none_of(exec, first, last, pred);
}


template<class ExecutionPolicy, class InputIterator, class T>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find(ExecutionPolicy &&exec, InputIterator first, InputIterator last, const T& value)
{
  return __find(exec, first, last, value);
}


template<class ExecutionPolicy, class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_if(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __find_if(exec, first, last, pred);
}


template<class ExecutionPolicy, class InputIterator, class Predicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_if_not(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __find_if_not(exec, first, last, pred);
}


template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator1>::type
find_end(ExecutionPolicy &&exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)
{
  return __find_end(exec, first1, last1, first2, last2);
}


template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
typename __enable_if_execution_policy<ExecutionPolicy,ForwardIterator1>::type
find_end(ExecutionPolicy &&exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred)
{
  return __find_end(exec, first1, last1, first2, last2, pred);
}


template<class ExecutionPolicy, class InputIterator, class ForwardIterator>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_first_of(ExecutionPolicy &&exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2)
{
  return __find_first_of(exec, first1, last1, first2, last2);
}


template<class ExecutionPolicy, class InputIterator, class ForwardIterator, class BinaryPredicate>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
find_first_of(ExecutionPolicy &&exec, InputIterator first1, InputIterator last1, ForwardIterator first2, ForwardIterator last2, BinaryPredicate pred)
{
  return __find_first_of(exec, first1, last1, first2, last2, pred);
}


template<typename ExecutionPolicy, typename InputIterator, typename T>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  typename iterator_traits<InputIterator>::difference_type
>::type
count(ExecutionPolicy &&exec, InputIterator first, InputIterator last, const T &value)
{
  return __count(exec, first, last, value);
}


template<typename ExecutionPolicy, typename InputIterator, typename Predicate>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  typename iterator_traits<InputIterator>::difference_type
>::type
count_if(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Predicate pred)
{
  return __count_if(exec, first, last, pred);
}


template<typename ExecutionPolicy, typename InputIterator1, typename InputIterator2>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  pair<InputIterator1,InputIterator2>
>::type
mismatch(ExecutionPolicy &&exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
  return __mismatch(exec, first1, last1, first2);
}


template<typename ExecutionPolicy, typename InputIterator1, typename InputIterator2, typename Predicate>
typename __enable_if_execution_policy<
  ExecutionPolicy,
  pair<InputIterator1,InputIterator2>
>::type
mismatch(ExecutionPolicy &&exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, Predicate pred)
{
  return __mismatch(exec, first1, last1, first2, pred);
}


template<typename ExecutionPolicy, typename InputIterator, typename Function>
typename __enable_if_execution_policy<ExecutionPolicy,InputIterator>::type
for_each(ExecutionPolicy &&exec, InputIterator first, InputIterator last, Function f)
{
  return __for_each(exec, first, last, f);
}


}

